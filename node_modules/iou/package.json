{
  "name": "iou",
  "version": "2.0.0",
  "description": "A JavaScript promise API.",
  "author": {
    "name": "Kris Walker",
    "email": "kris@kixx.name",
    "url": "http://www.kixx.name/"
  },
  "keywords": [
    "iou",
    "promise",
    "promises",
    "async",
    "defer",
    "deferred",
    "deferreds",
    "future",
    "futures"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/kixxauth/iou.git"
  },
  "bugs": {
    "url": "https://github.com/kixxauth/iou/issues"
  },
  "devDependencies": {
    "nodeunit": "0.8.1",
    "promises-aplus-tests": "2.0.3"
  },
  "readme": "IOU\n===\n\nA JavaScript library to shim Node.js with the upcoming JavaScript Promise API.\nThere are a lot of libraries that do this already:\n\n* [Q](https://github.com/kriskowal/q)\n* [RSVP.js](https://github.com/tildeio/rsvp.js)\n* [Promised-IO](https://github.com/kriszyp/promised-io)\n* [Promise](https://github.com/then/promise)\n* [micro-promise](https://github.com/Gozala/micro-promise)\n\nbut they all do a lot of other stuff too, which you may or may not want, and\nnot all of them fully implement the new Promise object that will be available\nsoon. IOU is designed to simply bring promises to Node.js in as small a package\nas possible.  There are no bells and whistles, no dependencies, just a simple\nAPI that should allow you to transition to the native Promise API as soon as it\narrives in Node land.\n\n## Installation\nThe most common use of IOU is to use it as a library. In that case, just\ninclude it in your Node.js project by adding a line for IOU in your\n`pacakge.json`. For more information about your `package.json` file, you should\ncheck out the npm documentation by running `npm help json`.\n\nAlternatively, you can quickly install IOU for use in a project by running\n\n\tnpm install iou\n\nwhich will install iou in your `node_modules/` folder.\n\n## Examples\n\nYou can create a new promise with the constructor, passing it a block of code\nin the form of a callback function. Inside that block of code is where the\nasynchronous call is made, and the promise is resolved or rejected:\n\n```JavaScript\nvar FS = require('fs')\n  , IOU = require('iou')\n\nvar readmePromise = new IOU.Promise(function (resolve, reject) {\n  FS.readFile('README.md', {encoding: 'utf8'}, function (err, text) {\n    if (err) return reject(err);\n    return resolve(text);\n  });\n})\n```\n\nOnce you have a promise, you can add handlers:\n```JavaScript\nfunction printText(text) {\n  console.log(text);\n}\n\n// The text String you passed into resolve() will get passed to printText().\nreadmePromise.then(printText);\n```\n\nAdd an error handler too:\n```JavaScript\n// Create an error handling function.\nfunction die(err) {\n  console.error(err.stack);\n  process.exit(1);\n}\n\n// The text String you passed into resolve() will get passed to printText(),\n// and the Error you passed into reject() will get passed to die().\nreadmePromise.then(printText, die);\n\n// We can improve this even more. By passing console.log as the success\n// handler, we don't even need our printText() function.\nreadmePromise.then(console.log, die);\n```\n\nPromises become super powerful in JavaScript when we need to compose a series\nof actions into a process where some of those actions involve asynchronous\noperations.\n\n```JavaScript\nfunction printWordCount(path) {\n  // Notice how obvious it is to understand what is happening here. Each of\n  // these functions will be called in the order given, but only after each\n  // previous one completes any asynchronous operations.\n  readFile(path)\n    .then(joinLines)\n    .then(splitWords)\n    .then(countWords)\n    .then(console.log)\n    .catch(die)\n\n  // If any errors are thrown in any of the functions in the chain, or if any\n  // of them rejects a promise, `catch(die)` will catch and handle them.\n}\n\nfunction readFile(path) {\n  var promise = new IOU.Promise(function (resolve, reject) {\n    FS.readFile(path, {encoding: 'utf8'}, function (err, text) {\n      if (err) return reject(err);\n      return resolve(text);\n    });\n  })\n}\n\nfunction joinLines(text) {\n  return text.split('\\n').join(' ');\n}\n\nfunction splitWords(text) {\n  return text.split(' ');\n}\n\nfunction countWords(words) {\n  return words.length;\n}\n\nfunction die(err) {\n  console.error(err.stack);\n  process.exit(1);\n}\n```\n\n## API Quick Reference\n\n### Module import\nImport IOU using require like this:\n```JavaScript\nvar IOU = require('iou')\n```\n\n### Promise Constructor\nConstruct a Promise instance by passing in a block of code in the form of a\ncallback function. Your callback function will be passed a resolve function\nand reject function as arguments. Use `resolve(value)` to resolve your promise\nto a given value, or use `reject(err)` to reject it with an Error.\n```JavaScript\n// Assuming you've already imported IOU like above:\n\nvar FS = require('fs')\n\nvar promise = new IOU.Promise(function (resolve, reject) {\n  FS.readFile('README.md', {encoding: 'utf8'}, function (err, text) {\n    if (err) return reject(err);\n    return resolve(text);\n  });\n})\n```\n\n### #then()\nOnce you have a Promise instance, you can attach resolve and reject listeners\nwith `then(onResolve, onReject)`. The first parameter `onResolve(value)` will\nbe passed the resolved value of the promise if it succeeds. The second\nparameter `onReject(err)` will be passed the rejected Error of the promise if\nit ends up getting rejected.\n\nIf you only care about rejections, you can pass `null` in place of\n`onResolve()`, and if you want to skip handling rejections then don't pass in\nthe `onReject()` handler at all.\n\nThe `then()` method returns the promise, so you can chain it to compose a\nsequence of actions, which is really powerful.\n```JavaScript\n  // Assuming we're using the promise we created above:\n\n  // Listen for both the resolved value, or rejected error:\n  promise.then(console.log, console.error);\n\n  // Listen for resolved values only:\n  promise.then(console.log);\n\n  // Listen for the rejected error only:\n  promise.then(null, console.error);\n\n  // Chain calls to `then()` like in the example code earlier:\n  readFile(path)\n    .then(joinLines, console.error)\n    .then(splitWords, console.error)\n    .then(countWords, console.error)\n    .then(console.log, console.error)\n```\n\n### #catch()\nThis is really just an alias for `then(null, onReject)`. This is a pattern that\nis good to use, since it catches any possible thrown errors or rejected promises\nthat have not been handled in the chain.\n```JavaScript\n\t// Simple use:\n  promise.then(console.log).catch(console.error);\n\n\t// A global error handler.\n  function die(err) {\n    console.error(err.stack);\n    process.exit(1);\n  }\n\n  // console.log() and console.error() should never throw, but if we pretend\n  // that they would, then using catch() would handle thrown errors or\n  // rejections from either of them.\n  promise.then(console.log, console.error).catch(die);\n\n  // catch() becomes much more useful in chaining, where errors or rejections\n  // can bubble up the chain and eventually all be caught by the handler given\n  // to catch() (aptly named). A good example comes from the example code from\n  // earlier:\n  readFile(path)\n    .then(joinLines)\n    .then(splitWords)\n    .then(countWords)\n    .then(console.log)\n    .catch(die)\n```\n\n### Promise.resolve()\nSometimes you need to simply pass back a promise from a normal synchronous\nfunction instead of a value.  That's what the `Promise.resolve()` class method\nallows you to do.\n```JavaScript\n// This function does not perform any asynchronous operations, but could be\n// used in a promise.then() chain if we return a promise instance.\nfunction getDaysInYear() {\n  return IOU.Promise.resolve(365);\n}\n\ngetDaysInYear().then(otherThing).catch(errorHandler);\n```\n\n### Promise.reject()\nOther times you need to turn an error into a rejection. That's what the\n`Promise.reject()` class method is used for. This is particularly useful in a\nresolved handler, where the rejection will get passed to the next rejection\nhandler.\n```JavaScript\nfunction catchEmptyFile(text) {\n  if (!text) {\n    var err = new Error(\"Empty file\");\n\n    // Use Promise.reject() to pass an error through the promise chain. If you\n    // didn't do this, then the next success handler would be called instead of\n    // the error handler.\n\n    return IOU.Promise.reject(err);\n  }\n  return text;\n}\n\nfunction die(err) {\n  console.error(err.stack);\n  process.exit(1);\n}\n\n// Using Promise.reject() in catchEmptyFile() will cause an empty file error\n// to be caught by catch(die), and console.log will never be called.\n\npromise.then(catchEmptyFile).then(console.log).catch(die);\n```\n\n### Promise.all()\nThe `Promise.all()` class method collects an array of promises and returns a\nnew promise that will only be resolved if all of the promises resolve. If any\none of them rejects, then the new promise returned by Promise.all() will reject\nwith the first rejection.\n\nNormal non-Promise values can also be passed in the array to `Promise.all()`\nand they will be casted to a Promise instance.\n```JavaScript\nfunction printAll(texts) {\n  console.log.call(console, texts);\n}\n\nvar promises = [readFile('./config.yaml'), \"host: localhost\", readFile('/home/kris/config.yaml')]\nIOU.Promise.all(promises).then(printAll).catch(die);\n```\n\n## Testing\nTo run the tests, just do\n\n\t./manage test\n\nA list of checkmarks followed by `OK` means the tests succeeded. Anything else\nshould print out a stack trace for you, indicating a test failure.\n\nCopyright and License\n---------------------\nCopyright (c) 2013 by Kris Walker <kris@kixx.name> (http://www.kixx.name).\n\nUnless otherwise indicated, all source code is licensed under the MIT license.\nSee LICENSE for details.\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/kixxauth/iou",
  "_id": "iou@2.0.0",
  "_from": "iou@~2.0.0"
}
